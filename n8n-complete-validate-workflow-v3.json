{
  "name": "User Validation - Complete Workflow v3 (No Strict Parser)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "validate",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [-400, 300],
      "id": "webhook-node",
      "name": "Webhook",
      "webhookId": "validate"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a user authentication agent. Validate user credentials and return ONLY raw JSON (no markdown, no code blocks, no explanations).\n\n## Your Task:\n1. You will receive username and passcode from the webhook request\n2. Use the Airtable tool to search for the user by username\n3. Validate the credentials and return user information in the exact JSON format\n\n## Input from Webhook:\n- Username: {{ $json.body.username }}\n- Passcode: {{ $json.body.passcode }}\n\n## Instructions:\n\nSTEP 1: Use the \"Search records in Airtable\" tool to find the user.\n- Tool name: \"Search records in Airtable\"\n- Search query: \"Username: {{ $json.body.username }}\"\n- This will search the \"User Accounts\" table for a user with matching username\n\nSTEP 2: Check if user was found:\n- If the tool returns no results or empty array → return: {\"success\": false, \"error\": \"Invalid username or passcode\"}\n- If the tool returns results → continue to STEP 3\n\nSTEP 3: Validate credentials:\n- Get the Password field from the Airtable record\n- Compare it with the passcode from the request (case-sensitive comparison)\n- If passwords match → proceed to STEP 4\n- If passwords don't match → return: {\"success\": false, \"error\": \"Invalid username or passcode\"}\n\nSTEP 4: Format success response:\n- Extract all user data from the Airtable record\n- Map fields according to the mapping rules below\n- Return success JSON\n\n## Output Format (CRITICAL - Return ONLY this JSON, nothing else):\n\nSuccess Response:\n{\"success\": true, \"user\": {\"id\": \"<airtable_record_id>\", \"email\": \"<email_or_null>\", \"username\": \"<username>\", \"role\": \"<role>\", \"clientId\": \"<client_id_or_null>\", \"kamId\": \"<kam_id_or_null>\", \"nbfcId\": \"<nbfc_id_or_null>\", \"name\": \"<name_or_null>\"}}\n\nError Response:\n{\"success\": false, \"error\": \"Invalid username or passcode\"}\n\n## Field Mapping from Airtable:\n- Airtable record \"id\" → response \"user.id\"\n- Airtable \"Email\" field → response \"user.email\" (use null if missing)\n- Airtable \"Username\" field → response \"user.username\"\n- Airtable \"Role\" field → response \"user.role\"\n- Airtable \"Client ID\" or \"ClientId\" field → response \"user.clientId\" (use null if missing)\n- Airtable \"KAM ID\" or \"KAMId\" field → response \"user.kamId\" (use null if missing)\n- Airtable \"NBFC ID\" or \"NBFCId\" field → response \"user.nbfcId\" (use null if missing)\n- Airtable \"Name\" field → response \"user.name\" (use null if missing)\n\n## Critical Rules:\n1. You MUST use the \"Search records in Airtable\" tool to find the user\n2. Return ONLY the JSON object - NO markdown, NO code blocks, NO text before/after\n3. Password comparison is case-sensitive\n4. Username comparison is case-insensitive\n5. If Airtable tool returns no results → return error immediately\n6. If password doesn't match → return error\n7. Use null (not empty string) for missing optional fields\n8. The response must be valid JSON that can be parsed",
        "hasOutputParser": false,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [0, 300],
      "id": "ai-agent-node",
      "name": "AI Agent: Validate Credentials"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "builtInTools": {},
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [-144, 500],
      "id": "openai-model-node",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "JWuuxy0L5XtsVuUU",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appzbyi8q7pJRl1cd",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tbl7RRcehD5xLiPv7",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.airtableTool",
      "typeVersion": 2.1,
      "position": [-144, 600],
      "id": "airtable-tool-node",
      "name": "Search records in Airtable",
      "credentials": {
        "airtableTokenApi": {
          "id": "7GvicfJT1nu7OUoa",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get AI output\nconst aiOutput = $input.item.json;\n\n// Extract JSON from markdown if present\nlet jsonString = '';\n\nif (aiOutput.output) {\n  // If wrapped in markdown code blocks\n  jsonString = aiOutput.output\n    .replace(/```json\\s*/g, '')\n    .replace(/```\\s*/g, '')\n    .trim();\n} else if (typeof aiOutput === 'string') {\n  jsonString = aiOutput\n    .replace(/```json\\s*/g, '')\n    .replace(/```\\s*/g, '')\n    .trim();\n} else if (aiOutput.text) {\n  // Sometimes AI returns in text field\n  jsonString = aiOutput.text\n    .replace(/```json\\s*/g, '')\n    .replace(/```\\s*/g, '')\n    .trim();\n} else {\n  // Already JSON object - validate and format\n  if (aiOutput.success === true && aiOutput.user) {\n    return {\n      json: {\n        success: true,\n        user: {\n          id: aiOutput.user.id || '',\n          email: aiOutput.user.email || null,\n          username: aiOutput.user.username || '',\n          role: aiOutput.user.role || 'client',\n          clientId: aiOutput.user.clientId || null,\n          kamId: aiOutput.user.kamId || null,\n          nbfcId: aiOutput.user.nbfcId || null,\n          name: aiOutput.user.name || null\n        }\n      }\n    };\n  } else {\n    return {\n      json: {\n        success: false,\n        error: aiOutput.error || 'Invalid username or passcode'\n      }\n    };\n  }\n}\n\n// Parse JSON\ntry {\n  const parsed = JSON.parse(jsonString);\n  \n  // Validate and format response\n  if (parsed.success === true && parsed.user) {\n    return {\n      json: {\n        success: true,\n        user: {\n          id: parsed.user.id || '',\n          email: parsed.user.email || null,\n          username: parsed.user.username || '',\n          role: parsed.user.role || 'client',\n          clientId: parsed.user.clientId || null,\n          kamId: parsed.user.kamId || null,\n          nbfcId: parsed.user.nbfcId || null,\n          name: parsed.user.name || null\n        }\n      }\n    };\n  } else {\n    return {\n      json: {\n        success: false,\n        error: parsed.error || 'Invalid username or passcode'\n      }\n    };\n  }\n} catch (error) {\n  // If parsing fails, try to extract JSON from the string\n  try {\n    // Try to find JSON object in the string\n    const jsonMatch = jsonString.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      const parsed = JSON.parse(jsonMatch[0]);\n      if (parsed.success === true && parsed.user) {\n        return {\n          json: {\n            success: true,\n            user: {\n              id: parsed.user.id || '',\n              email: parsed.user.email || null,\n              username: parsed.user.username || '',\n              role: parsed.user.role || 'client',\n              clientId: parsed.user.clientId || null,\n              kamId: parsed.user.kamId || null,\n              nbfcId: parsed.user.nbfcId || null,\n              name: parsed.user.name || null\n            }\n          }\n        };\n      } else {\n        return {\n          json: {\n            success: false,\n            error: parsed.error || 'Invalid username or passcode'\n          }\n        };\n      }\n    }\n  } catch (e) {\n    // If all parsing fails, return error\n    return {\n      json: {\n        success: false,\n        error: \"Failed to parse AI response. Raw output: \" + jsonString.substring(0, 200)\n      }\n    };\n  }\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [200, 300],
      "id": "code-clean-node",
      "name": "Code: Clean & Validate Response"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [400, 300],
      "id": "respond-webhook-node",
      "name": "Respond to Webhook"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "AI Agent: Validate Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent: Validate Credentials": {
      "main": [
        [
          {
            "node": "Code: Clean & Validate Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent: Validate Credentials",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Search records in Airtable": {
      "ai_tool": [
        [
          {
            "node": "AI Agent: Validate Credentials",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Code: Clean & Validate Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2026-01-05T18:00:00.000Z",
  "versionId": "1"
}

